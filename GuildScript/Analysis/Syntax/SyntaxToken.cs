using GuildScript.Analysis.Text;

namespace GuildScript.Analysis.Syntax;

public enum SyntaxTokenType
{
	// Special Tokens
	Invalid = -1,
	EndOfFile,

	// Operators
	Amp,
	AmpAmp,
	AmpEqual,
	AmpAmpEqual,
	Bang,
	BangEqual,
	BangDot,
	Equal,
	EqualEqual,
	LeftAngled,
	LeftAngledEqual,
	RightAngled,
	RightAngledEqual,
	Plus,
	PlusPlus,
	PlusEqual,
	Minus,
	MinusMinus,
	MinusEqual,
	Star,
	StarStar,
	StarEqual,
	StarStarEqual,
	Slash,
	SlashEqual,
	Caret,
	CaretCaret,
	CaretEqual,
	CaretCaretEqual,
	Pipe,
	PipePipe,
	PipeEqual,
	PipePipeEqual,
	Percent,
	PercentEqual,
	OpenParen,
	CloseParen,
	OpenBrace,
	CloseBrace,
	OpenSquare,
	CloseSquare,
	Comma,
	Dot,
	Semicolon,
	Colon,
	Tilde,
	LeftTriangle,
	RightTriangle,
	LeftLeftEqual,
	LeftLeftLeftEqual,
	RightRightEqual,
	RightRightRightEqual,
	LeftArrow,
	LeftArrowArrow,
	RightArrow,
	RightArrowArrow,
	Question,
	QuestionQuestion,
	QuestionEqual,
	QuestionBangEqual,
	QuestionColon,
	QuestionQuestionEqual,
	QuestionDot,
	QuestionOpenSquare,

	// Constants
	RealConstant,
	IntegerConstant,
	StringConstant,
	CharacterConstant,
	True,
	False,
	Null,

	// Keywords
	Identifier,
	Define,
	As,
	Var,
	Async,
	Await,
	For,
	Foreach,
	In,
	Public,
	Private,
	Protected,
	Internal,
	External,
	Class,
	Struct,
	Interface,
	Enum,
	This,
	Base,
	Global,
	Template,
	Lock,
	Import,
	Module,
	Entry,
	Final,
	Shared,
	Required,
	Prototype,
	Return,
	Void,
	Constructor,
	Destructor,
	Seal,
	Constant,
	Fixed,
	Immutable,
	Throw,
	Try,
	Catch,
	Finally,
	If,
	Else,
	While,
	Do,
	Repeat,
	New,
	Switch,
	Case,
	Default,
	Continue,
	Break,
	Get,
	Set,
	Event,
	Ref,

	// Built-in types
	Int8,
	UInt8,
	Int16,
	UInt16,
	Int32,
	UInt32,
	Int64,
	UInt64,
	Single,
	Double,
	Bool,
	String,
	Char,
	Object
}

public sealed class SyntaxToken
{
	public SyntaxTokenType Type { get; }
	public string Text { get; }
	public object? Value { get; }
	public TextSpan Span { get; }

	public SyntaxToken(SyntaxTokenType type, string text, object? value, TextSpan span)
	{
		Type = type;
		Text = text;
		Value = value;
		Span = span;
	}
	
	public static SyntaxTokenType LookupIdentifier(string identifier)
	{
		var type = identifier switch
		{
			"true"        => SyntaxTokenType.True,
			"false"       => SyntaxTokenType.False,
			"null"        => SyntaxTokenType.Null,
			
			"define"      => SyntaxTokenType.Define,
			"as"          => SyntaxTokenType.As,
			"var"         => SyntaxTokenType.Var,
			"async"       => SyntaxTokenType.Async,
			"await"       => SyntaxTokenType.Await,
			"for"         => SyntaxTokenType.For,
			"foreach"     => SyntaxTokenType.Foreach,
			"in"          => SyntaxTokenType.In,
			"public"      => SyntaxTokenType.Public,
			"private"     => SyntaxTokenType.Private,
			"protected"   => SyntaxTokenType.Protected,
			"internal"    => SyntaxTokenType.Internal,
			"external"    => SyntaxTokenType.External,
			"class"       => SyntaxTokenType.Class,
			"struct"      => SyntaxTokenType.Struct,
			"interface"   => SyntaxTokenType.Interface,
			"enum"        => SyntaxTokenType.Enum,
			"this"        => SyntaxTokenType.This,
			"base"        => SyntaxTokenType.Base,
			"global"      => SyntaxTokenType.Global,
			"template"    => SyntaxTokenType.Template,
			"lock"        => SyntaxTokenType.Lock,
			"import"      => SyntaxTokenType.Import,
			"module"      => SyntaxTokenType.Module,
			"entry"       => SyntaxTokenType.Entry,
			"final"       => SyntaxTokenType.Final,
			"shared"      => SyntaxTokenType.Shared,
			"required"    => SyntaxTokenType.Required,
			"prototype"   => SyntaxTokenType.Prototype,
			"return"      => SyntaxTokenType.Return,
			"void"        => SyntaxTokenType.Void,
			"constructor" => SyntaxTokenType.Constructor,
			"destructor"  => SyntaxTokenType.Destructor,
			"seal"        => SyntaxTokenType.Seal,
			"constant"    => SyntaxTokenType.Constant,
			"fixed"       => SyntaxTokenType.Fixed,
			"immutable"   => SyntaxTokenType.Immutable,
			"throw"       => SyntaxTokenType.Throw,
			"try"         => SyntaxTokenType.Try,
			"catch"       => SyntaxTokenType.Catch,
			"finally"     => SyntaxTokenType.Finally,
			"if"          => SyntaxTokenType.If,
			"else"        => SyntaxTokenType.Else,
			"while"       => SyntaxTokenType.While,
			"do"          => SyntaxTokenType.Do,
			"repeat"      => SyntaxTokenType.Repeat,
			"new"         => SyntaxTokenType.New,
			"switch"      => SyntaxTokenType.Switch,
			"case"        => SyntaxTokenType.Case,
			"default"     => SyntaxTokenType.Default,
			"continue"    => SyntaxTokenType.Continue,
			"break"       => SyntaxTokenType.Break,
			"get"         => SyntaxTokenType.Get,
			"set"         => SyntaxTokenType.Set,
			"event"		  => SyntaxTokenType.Event,
			"ref"		  => SyntaxTokenType.Ref,
			
			"int8"   => SyntaxTokenType.Int8,
			"uint8"  => SyntaxTokenType.UInt8,
			"int16"  => SyntaxTokenType.Int16,
			"uint16" => SyntaxTokenType.UInt16,
			"int32"  => SyntaxTokenType.Int32,
			"uint32" => SyntaxTokenType.UInt32,
			"int"    => SyntaxTokenType.Int32,
			"uint"   => SyntaxTokenType.UInt32,
			"int64"  => SyntaxTokenType.Int64,
			"uint64" => SyntaxTokenType.UInt64,
			"single" => SyntaxTokenType.Single,
			"double" => SyntaxTokenType.Double,
			"bool"   => SyntaxTokenType.Bool,
			"string" => SyntaxTokenType.String,
			"char"   => SyntaxTokenType.Char,
			"object" => SyntaxTokenType.Object,
			
			_             => SyntaxTokenType.Identifier
		};
		
		return type;
	}
}